{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef } from \"react\";\nimport { useReactFlow, useStore, Position } from \"reactflow\";\nimport { timer } from \"d3-timer\";\nimport dagre from \"dagre\";\nconst nodeWidth = 210;\nconst nodeHeight = 100;\nconst getLayoutedElements = (nodes, edges, direction = \"TB\") => {\n  const dagreGraph = new dagre.graphlib.Graph();\n  dagreGraph.setDefaultEdgeLabel(() => ({}));\n  const isHorizontal = direction === \"LR\";\n  dagreGraph.setGraph({\n    rankdir: direction\n  });\n  nodes.forEach(el => {\n    dagreGraph.setNode(el.id, {\n      width: nodeWidth,\n      height: nodeHeight\n    });\n  });\n  edges.forEach(el => {\n    dagreGraph.setEdge(el.source, el.target);\n  });\n  dagre.layout(dagreGraph);\n  const newNodes = nodes.map(el => {\n    const nodeWithPosition = dagreGraph.node(el.id);\n    el.targetPosition = isHorizontal ? Position.Left : Position.Bottom;\n    el.sourcePosition = isHorizontal ? Position.Right : Position.Top;\n\n    // unfortunately we need this little hack to pass a slighltiy different position\n    // to notify react flow about the change. More over we are shifting the dagre node position\n    // (anchor=center center) to the top left so it matches the react flow node anchor point (top left).\n    el.position = {\n      x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1000,\n      y: nodeWithPosition.y - nodeHeight / 2\n    };\n    return el;\n  });\n  const newEdges = edges.map(edge => {\n    return {\n      ...edge,\n      sourceHandle: direction === \"TB\" ? Position.Bottom : Position.Right,\n      targetHandle: direction === \"TB\" ? Position.Top : Position.Left\n    };\n  });\n  return {\n    newNodes,\n    newEdges\n  };\n};\nconst options = {\n  duration: 300\n};\n\n// function configureLayout(direction: \"TB\" | \"LR\") {\n//   const layout = tree<Node>();\n\n//   if (direction === \"TB\") {\n//     // Top-to-Bottom\n//     layout.nodeSize([200, 150]); // [width, height]\n//   } else if (direction === \"LR\") {\n//     // Left-to-Right\n//     layout.nodeSize([150, 250]); // [height, width]\n//   }\n\n//   console.log({ direction });\n\n//   layout.separation(() => 1); // Create equal spacing between nodes\n//   return layout;\n// }\n\n// the layouting function\n// accepts current nodes and edges and returns the layouted nodes with their updated positions\n// function layoutNodes(\n//   nodes: Node[],\n//   edges: Edge[],\n//   direction: \"TB\" | \"LR\"\n// ): Node[] {\n//   // if there are no nodes we can't calculate a layout\n//   if (nodes.length === 0) {\n//     return [];\n//   }\n\n//   const layout = configureLayout(direction);\n\n//   // convert nodes and edges into a hierarchical object for using it with the layout function\n//   const hierarchy = stratify<Node>()\n//     .id((d) => d.id)\n//     // get the id of each node by searching through the edges\n//     // this only works if every node has one connection\n//     .parentId((d: Node) => edges.find((e: Edge) => e.target === d.id)?.source)(\n//     nodes\n//   );\n\n//   // run the layout algorithm with the hierarchy data structure\n//   const root = layout(hierarchy);\n\n//   // convert the hierarchy back to react flow nodes (the original node is stored as d.data)\n//   // we only extract the position from the d3 function\n//   return root.descendants().map((d) => ({\n//     ...d.data,\n//     position: direction === \"TB\" ? { x: d.x, y: d.y } : { x: d.y, y: d.x },\n//   }));\n// }\n\n// this is the store selector that is used for triggering the layout, this returns the number of nodes once they change\nconst nodeCountSelector = state => state.nodeInternals.size;\nfunction useLayout(direction) {\n  _s();\n  // this ref is used to fit the nodes in the first run\n  // after first run, this is set to false\n  const initial = useRef(true);\n\n  // we are using nodeCount as the trigger for the re-layouting\n  // whenever the nodes length changes, we calculate the new layout\n  const nodeCount = useStore(nodeCountSelector);\n  const {\n    getNodes,\n    getNode,\n    setNodes,\n    setEdges,\n    getEdges,\n    fitView\n  } = useReactFlow();\n  useEffect(() => {\n    // get the current nodes and edges\n    const nodes = getNodes();\n    const edges = getEdges();\n\n    // run the layout and get back the nodes with their updated positions\n    const {\n      newEdges,\n      newNodes\n    } = getLayoutedElements(nodes, edges, direction);\n\n    // if you do not want to animate the nodes, you can uncomment the following line\n    // return setNodes(targetNodes);\n    setEdges(newEdges);\n\n    // to interpolate and animate the new positions, we create objects that contain the current and target position of each node\n    const transitions = newNodes.map(node => {\n      var _getNode;\n      return {\n        id: node.id,\n        // this is where the node currently is placed\n        from: ((_getNode = getNode(node.id)) === null || _getNode === void 0 ? void 0 : _getNode.position) || node.position,\n        // this is where we want the node to be placed\n        to: node.position,\n        node\n      };\n    });\n\n    // create a timer to animate the nodes to their new positions\n    const t = timer(elapsed => {\n      const s = elapsed / options.duration;\n      const currNodes = transitions.map(({\n        node,\n        from,\n        to\n      }) => {\n        return {\n          id: node.id,\n          position: {\n            // simple linear interpolation\n            x: from.x + (to.x - from.x) * s,\n            y: from.y + (to.y - from.y) * s\n          },\n          data: {\n            ...node.data\n          },\n          type: node.type\n        };\n      });\n      setNodes(currNodes);\n\n      // this is the final step of the animation\n      if (elapsed > options.duration) {\n        // we are moving the nodes to their destination\n        // this needs to happen to avoid glitches\n        const finalNodes = transitions.map(({\n          node,\n          to\n        }) => {\n          return {\n            id: node.id,\n            position: {\n              x: to.x,\n              y: to.y\n            },\n            data: {\n              ...node.data\n            },\n            type: node.type\n          };\n        });\n        setNodes(finalNodes);\n\n        // stop the animation\n        t.stop();\n\n        // in the first run, fit the view\n        if (!initial.current) {\n          fitView({\n            duration: 200,\n            padding: 0.2\n          });\n        }\n        initial.current = false;\n      }\n    });\n    return () => {\n      t.stop();\n    };\n  }, [nodeCount, getEdges, getNodes, getNode, setNodes, fitView, setEdges, direction]);\n}\n_s(useLayout, \"zrYtkHcqYIaExcPTXKgkfLp496k=\", false, function () {\n  return [useStore, useReactFlow];\n});\nexport default useLayout;","map":{"version":3,"names":["useEffect","useRef","useReactFlow","useStore","Position","timer","dagre","nodeWidth","nodeHeight","getLayoutedElements","nodes","edges","direction","dagreGraph","graphlib","Graph","setDefaultEdgeLabel","isHorizontal","setGraph","rankdir","forEach","el","setNode","id","width","height","setEdge","source","target","layout","newNodes","map","nodeWithPosition","node","targetPosition","Left","Bottom","sourcePosition","Right","Top","position","x","Math","random","y","newEdges","edge","sourceHandle","targetHandle","options","duration","nodeCountSelector","state","nodeInternals","size","useLayout","_s","initial","nodeCount","getNodes","getNode","setNodes","setEdges","getEdges","fitView","transitions","_getNode","from","to","t","elapsed","s","currNodes","data","type","finalNodes","stop","current","padding"],"sources":["/home/vijay-rathod/Downloads/workflow-builder-example (2)/src/hooks/useLayout.ts"],"sourcesContent":["import { useEffect, useRef } from \"react\";\nimport {\n  useReactFlow,\n  useStore,\n  Node,\n  Edge,\n  ReactFlowState,\n  Position,\n} from \"reactflow\";\nimport { timer } from \"d3-timer\";\nimport dagre from \"dagre\";\n\nconst nodeWidth = 210;\nconst nodeHeight = 100;\n\nconst getLayoutedElements = (\n  nodes: Node[],\n  edges: Edge[],\n  direction = \"TB\"\n) => {\n  const dagreGraph = new dagre.graphlib.Graph();\n\n  dagreGraph.setDefaultEdgeLabel(() => ({}));\n\n  const isHorizontal = direction === \"LR\";\n  dagreGraph.setGraph({ rankdir: direction });\n\n  nodes.forEach((el) => {\n    dagreGraph.setNode(el.id, { width: nodeWidth, height: nodeHeight });\n  });\n\n  edges.forEach((el) => {\n    dagreGraph.setEdge(el.source, el.target);\n  });\n\n  dagre.layout(dagreGraph);\n\n  const newNodes = nodes.map((el) => {\n    const nodeWithPosition = dagreGraph.node(el.id);\n    el.targetPosition = isHorizontal ? Position.Left : Position.Bottom;\n    el.sourcePosition = isHorizontal ? Position.Right : Position.Top;\n\n    // unfortunately we need this little hack to pass a slighltiy different position\n    // to notify react flow about the change. More over we are shifting the dagre node position\n    // (anchor=center center) to the top left so it matches the react flow node anchor point (top left).\n    el.position = {\n      x: nodeWithPosition.x - nodeWidth / 2 + Math.random() / 1000,\n      y: nodeWithPosition.y - nodeHeight / 2,\n    };\n\n    return el;\n  });\n\n  const newEdges = edges.map((edge) => {\n    return {\n      ...edge,\n      sourceHandle: direction === \"TB\" ? Position.Bottom : Position.Right,\n      targetHandle: direction === \"TB\" ? Position.Top : Position.Left,\n    };\n  });\n  return { newNodes, newEdges };\n};\n\nconst options = { duration: 300 };\n\n// function configureLayout(direction: \"TB\" | \"LR\") {\n//   const layout = tree<Node>();\n\n//   if (direction === \"TB\") {\n//     // Top-to-Bottom\n//     layout.nodeSize([200, 150]); // [width, height]\n//   } else if (direction === \"LR\") {\n//     // Left-to-Right\n//     layout.nodeSize([150, 250]); // [height, width]\n//   }\n\n//   console.log({ direction });\n\n//   layout.separation(() => 1); // Create equal spacing between nodes\n//   return layout;\n// }\n\n// the layouting function\n// accepts current nodes and edges and returns the layouted nodes with their updated positions\n// function layoutNodes(\n//   nodes: Node[],\n//   edges: Edge[],\n//   direction: \"TB\" | \"LR\"\n// ): Node[] {\n//   // if there are no nodes we can't calculate a layout\n//   if (nodes.length === 0) {\n//     return [];\n//   }\n\n//   const layout = configureLayout(direction);\n\n//   // convert nodes and edges into a hierarchical object for using it with the layout function\n//   const hierarchy = stratify<Node>()\n//     .id((d) => d.id)\n//     // get the id of each node by searching through the edges\n//     // this only works if every node has one connection\n//     .parentId((d: Node) => edges.find((e: Edge) => e.target === d.id)?.source)(\n//     nodes\n//   );\n\n//   // run the layout algorithm with the hierarchy data structure\n//   const root = layout(hierarchy);\n\n//   // convert the hierarchy back to react flow nodes (the original node is stored as d.data)\n//   // we only extract the position from the d3 function\n//   return root.descendants().map((d) => ({\n//     ...d.data,\n//     position: direction === \"TB\" ? { x: d.x, y: d.y } : { x: d.y, y: d.x },\n//   }));\n// }\n\n// this is the store selector that is used for triggering the layout, this returns the number of nodes once they change\nconst nodeCountSelector = (state: ReactFlowState) => state.nodeInternals.size;\n\nfunction useLayout(direction: \"TB\" | \"LR\") {\n  // this ref is used to fit the nodes in the first run\n  // after first run, this is set to false\n  const initial = useRef(true);\n\n  // we are using nodeCount as the trigger for the re-layouting\n  // whenever the nodes length changes, we calculate the new layout\n  const nodeCount = useStore(nodeCountSelector);\n\n  const { getNodes, getNode, setNodes, setEdges, getEdges, fitView } =\n    useReactFlow();\n\n  useEffect(() => {\n    // get the current nodes and edges\n    const nodes = getNodes();\n    const edges = getEdges();\n\n    // run the layout and get back the nodes with their updated positions\n    const { newEdges, newNodes } = getLayoutedElements(nodes, edges, direction);\n\n    // if you do not want to animate the nodes, you can uncomment the following line\n    // return setNodes(targetNodes);\n    setEdges(newEdges);\n\n    // to interpolate and animate the new positions, we create objects that contain the current and target position of each node\n    const transitions = newNodes.map((node) => {\n      return {\n        id: node.id,\n        // this is where the node currently is placed\n        from: getNode(node.id)?.position || node.position,\n        // this is where we want the node to be placed\n        to: node.position,\n        node,\n      };\n    });\n\n    // create a timer to animate the nodes to their new positions\n    const t = timer((elapsed: number) => {\n      const s = elapsed / options.duration;\n\n      const currNodes = transitions.map(({ node, from, to }) => {\n        return {\n          id: node.id,\n          position: {\n            // simple linear interpolation\n            x: from.x + (to.x - from.x) * s,\n            y: from.y + (to.y - from.y) * s,\n          },\n          data: { ...node.data },\n          type: node.type,\n        };\n      });\n\n      setNodes(currNodes);\n\n      // this is the final step of the animation\n      if (elapsed > options.duration) {\n        // we are moving the nodes to their destination\n        // this needs to happen to avoid glitches\n        const finalNodes = transitions.map(({ node, to }) => {\n          return {\n            id: node.id,\n            position: {\n              x: to.x,\n              y: to.y,\n            },\n            data: { ...node.data },\n            type: node.type,\n          };\n        });\n\n        setNodes(finalNodes);\n\n        // stop the animation\n        t.stop();\n\n        // in the first run, fit the view\n        if (!initial.current) {\n          fitView({ duration: 200, padding: 0.2 });\n        }\n        initial.current = false;\n      }\n    });\n\n    return () => {\n      t.stop();\n    };\n  }, [\n    nodeCount,\n    getEdges,\n    getNodes,\n    getNode,\n    setNodes,\n    fitView,\n    setEdges,\n    direction,\n  ]);\n}\n\nexport default useLayout;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}